% --------------------------------------------------
% 
% This chapter is for dingo
% 
% --------------------------------------------------

\chapter{Software development to establish metabolic flux sampling 
         approaches at the community level}
\label{cha:dingo}


\section{A New MCMC Algorithm for Sampling the Flux Space of
Metabolic Networks}

   Publication relative to this chapter: \cite{chalki2021SoCG}

\subsection{Introduction}


   Systems Biology is a fundamental field and paradigm that represents a crucial era in Biology. 
   Its functionality and usefulness rely on metabolic networks that model the reactions occurring inside an organism and provide the means to understand the underlying mechanisms that govern biological systems. 
   We address the problem of sampling uniformly steady states of a metabolic network. 
   We use a convex polytope to represent this set. 
   However, the polytopes that result from biological data are of very high dimension (in the order of thousands) and in most, if not all, the cases are considerably skinny. 
   Therefore, to perform uniform sampling efficiently in this setting, we need a novel algorithmic and computational framework specially tailored for the properties of metabolic networks. 
   We present a complete software framework to handle sampling from convex polytopes that result from metabolic networks. 
   Its backbone is a Multiphase Monte Carlo Sampling (MMCS) algorithm.
   We demonstrate the efficiency of our approach by performing extensive experiments on various metabolic networks. 
   Notably, sampling on the most complicated human metabolic network accessible today, Recon3D, corresponding to a polytope of dimension $5\,335$, took less than $30$ hours. 
   To the best of our knowledge, that is out of reach for existing software.

   \begin{figure}[!htbp]
      \includegraphics[width=1.0\columnwidth]{figures/flux_sampling_workflow.png}
      \caption[From DNA sequences to distributions of metabolic fluxes]{
         From DNA sequences to distributions of metabolic fluxes.
         (A) The genes of an organism provide us with the enzymes that it can potentially produce. Enzymes are like a blueprint for the reactions they can catalyze.
         (B) Using the enzymes we identify the reactions in the organism.
         (C) We construct the stoichiometric matrix of the metabolic  model.
         (D) We consider the flux space under different conditions (e.g., steady states);
         they correspond  to  polytopes containing flux vectors addressing these conditions.
         (E) We sample from polytopes that are typically skinny and of high dimension.
         (F) The distribution of the flux of a reaction provides  great insights
         to biologists.
      }
      \label{fig:sampling_workflow}
   \end{figure}

   But why being interested in such a task ? The genome of most bacteria are rather short to have issues like that. 

   However, MAGs can be brought together and build the metabolic model of a whole community! 



   \begin{figure}[h]
      \centering
      \includegraphics[width=125mm]{figures/copulas_cropped.png}
      \caption[Flux distributions in the most recent human metabolic network Recon3D]{
         Flux distributions in the most recent human metabolic network Recon3D~\cite{brunk2018recon3d}. 
         We estimate the flux distributions of the reactions catalyzed by the enzymes Hexokinase (D-Glucose:ATP) (HEX), Glucose-6-Phosphate Phosphatase, Edoplasmic Reticular (G6PPer)
         and Phosphoenolpyruvate carboxykinase (GTP) (PEPCK).
         As we sample steady states, the production rate of $glc\_\_D \_c$ should be equal to its consumption rate. 
         Thus, in the corresponding copula, we see a positive dependency between HEX,
         i.e., the reaction that consumes $glc\_\_D \_c$ and G6PPer, that produces it.
         Furthermore, the PEPCK reaction operates when there is no $glc\_\_D\_c$ available and does not operate when the latter is present.
         Thus, in their copula we observe a negative dependency between HEX and PEPCK.
         A copula is a bivariate probability distribution for which the marginal probability distribution of each variable is uniform.
         It implies a positive dependency when the mass of the distribution concentrates along the up-diagonal (HEX - G6PPer)
         and a negative dependency when the mass is concentrated along the down-diagonal (HEX - PEPCK). %~\cite{Cales18}.
         The bottom line contains the  reactions and their stoichiometry.
      }
      \label{fig:sampling-on-recond3d}
   \end{figure}


% MMCS CONTRIBUTION
\subsection{Contribution}

   We introduce a Multi-phase Monte Carlo Sampling (MMCS) algorithm
   % (Section~\ref{sec:MMCS} and Algorithm~\ref{alg:MMCS})
   to sample from a polytope~$P$. 
   In particular, we split the sampling procedure in phases where, starting from $P$,
   each phase uses the sample to round the polytope and provide it as input to the next phase.
   
   This improves the efficiency of the random walk in the next phase, see
   % Figure~\ref{fig:mmcs_phases} and Table~\ref{tab:sampling_phases}. 
   For sampling, we propose an improved variant of Billiard Walk 
   % (Section~\ref{sec:billiard} and Algorithm~\ref{alg:billiard}) 
   that enjoys faster arithmetic complexity per step. 
   We also handle efficiently the potential arithmetic inaccuracies near to the boundary, see~\cite{ChePioCaz18} for a detailed treatment.

   We accompany the MMCS algorithm with a powerful MCMC diagnostic, namely the
   estimation of Effective Sample Size (ESS), to identify a satisfactory
   convergence to the uniform distribution. However, our method is flexible and we
   can use any random walk and combination of MCMC diagnostics to decide
   convergence.

   The open-source implementation of our algorithms%
   \footnote{\url{https://github.com/GeomScale/volume_approximation/tree/v1.1.0-2}} 
   provides a complete software framework to sample efficiently in metabolic networks. 
   We demonstrate the efficiency of our tools by performing experiments on almost all
   the metabolic networks that are publicly available and by comparing with the
   state-of-the-art software packages, like \texttt{cobra}
   % (Section~\ref{subsec:experiments}). 
   Our implementation is faster than \texttt{cobra}
   for low dimensional models, with a speed-up that ranges from $10$ to $100$
   times; 
   this gap on running times increases for bigger models
   % (Table~\ref{tab:results1}). 
   We measure the quality of the sample our software produces using two widely used diagnostics, i.e., ESS and potential scale reduction factor (PSRF)~\cite{Gelman92}. 
   The highlight of our method is the ability to sample from the most complicated human metabolic network that is accessible today, namely Recon3D. 
   In Figure 1 
   % ~\ref{fig:copulas} 
   we estimate marginal univariate and bivariate flux distributions in Recon3D which validate: 

   \begin{itemize}
      \item the quality of the sample by confirming a mutually exclusive pair of biochemical pathways, and that
      \item our method indeed generates steady states. 
   \end{itemize} 
   
   In particular, our software can sample $1.44\cdot 10^5$ points from  a $5\,335$-dimensional polytope in a day using modest hardware. 
   This set of points suffices for the majority of systems biology analytics. 
   To our understanding this task is out of reach for existing software.

   Lastly, MMCS algorithm is quite general sampling scheme and so it has the potential 
   to also address other hard computational problems like multivariate integration 
   and volume estimation of polytopes. 

   A preliminary version of this paper appeared in~\cite{chalki2021SoCG}. 
   The current full version contains additional and more detailed experimental results, all the proofs of the various statements and theorems, the pseudocode of all the algorithms, an updated discussion of previous work,
   and a more detailed presentation of our approach and tools.

   % --------------  like a "bridge" ------------

   % In the next section we present a thorough description of both the biological and the geometrical
   % notions that are the backbone of our framework. 
   % Section~\ref{sec:billiard}
   % details the Billard Walk random walk, while we introduce our Multiphase Monte Carlo
   % Sampling algorithms in 
   % Section~\ref{sec:MMCS}.
   % Finally, in
   % Section~\ref{sec:experiments} 
   % we present our open-source implementation and various
   % experimental results to highlight he potential our approach. 
   % We conclude in
   % Section~\ref{sec:conclusion}, where we also present some future directions.




% MMCS METHODS
\subsection{Methods \& Implementation}


\subsubsection*{Efficient Billiard walk}

   \begin{figure}[h]
      \centering
      \textbf{Algorithm 1: }Billiard Walk$(P, p, \rho, \tau, W)$
      \medskip

      \begin{algorithmic}
         \REQUIRE polytope $P$; point $p \in P$; upper bound on the number of reflections
         $\rho$; \\ parameter $\tau$ to adjust the length of the trajectory; walk length $W$.
         \ENSURE a point in $P$ (uniformly distributed in $P$).
         \FOR {$j=1,\dots ,W$} 
         \STATE {
            $L \leftarrow -\tau\ln\eta$;  $\ \eta\sim \mathcal{U}(0,1) \quad$ \COMMENT{
               {\textit{length of the trajectory}}
               }
            $i\leftarrow 0 \quad $ \COMMENT{
               {\textit{current number of reflections}}
               }
            $p_0\leftarrow p \quad $ \COMMENT{
               {\textit{initial point of the step}}
               }
            pick a uniform vector $u_0$ from the unit sphere
            \COMMENT{
               {\textit{initial direction}}}
         }
         \WHILE{$i\leq \rho$}
         \STATE{$\ell \leftarrow \{p_i + tu_i, 0\leq t\leq L\} \quad$} \COMMENT{
            {\textit{this is a segment}}}

         \IF{$\partial P \cap \ell = \O$} 
            \STATE{$p_{i+1} \leftarrow p_i+Lu_i \quad$
                  \textbf{break} \;}
         \ENDIF
         
         \STATE{$p_{i+1} \leftarrow \partial P\cap\ell ; \quad$}
         \COMMENT{
            {\textit{point update}}
            }
            
         \STATE{the inner vector, $s$, of the tangent plane at $p$, \\
            \ \ s.t.\ $||s|| = 1$,\; $L \leftarrow L - |P\cap\ell|$,
         $u_{i+1} \leftarrow u_i - 2(u_i^Ts) s \quad$}
         \COMMENT{
            {\textit{direction update}}
            }

         \STATE{$i \leftarrow i+1$}

         \ENDWHILE
      
         \IF{$i=\rho$}
            \STATE{$p \leftarrow p_0$}
         \ELSE	
            \STATE{$p \leftarrow p_i$}
         \ENDIF
         

         \ENDFOR

      \RETURN $p$\;


      \end{algorithmic}
      \label{alg:billiard}   
   \end{figure}

   At each step of Billiard Walk, we compute the intersection point of a ray, say
   $\ell:=\{p+tu,\ t\in\mathbb{R}_+ \}$,
   with the boundary of $P$, $\partial P$, and the normal vector of the tangent
   plane of $P$ at the intersection point.
   The inner vector of the facet that the intersection  point belongs to is a row of $A$.
   To compute the point $\partial P\cap\ell$ where the first reflection of a Billiard Walk
   step takes place we need to compute the intersection of $\ell$ with all the hyperplanes that define the facets of $P$.
   This corresponds to solve (independently) the following $m$ linear equations
   \begin{equation}
     a_j^T(p_0 + t_ju_0) = b_j \Rightarrow t_j = (b_j - a_j^Tp_0) / a_j^Tu_0,\ j \in[k],
   \end{equation}
   and keep the smallest positive $t_j$; $a_j$ is the $j$-th row of the matrix $A$.
   We solve each equation in $\mathcal{O}(d)$ operations and so the overall complexity is
   $\mathcal{O}(d k)$, where $k$ is the number of rows of $A$ and thus an upper bound on
   the number of facets of $P$. A straightforward approach for Billiard Walk would
   consider that each reflection costs $\mathcal{O}(k d)$ and thus the per step cost is
   $\mathcal{O}(\rho kd)$. However, our improved version performs more efficiently both
   \textit{point} and \textit{direction updates} in pseudo-code by storing some
   computations from the previous iteration combined with a preprocessing step. The
   preprocessing step involves the normal vectors of the facets and takes $k^2 d$
   operations. So the amortized per-step complexity of Billiard Walk becomes
   $\mathcal{O}((\rho + d)k)$. The pseudo-code appear in Algorithm~\ref{alg:billiard}.
   
   
   
   % lemma 
   % \begin{lem}
   %     \label{lem:BW-step-cost}
   %     The amortized cost per step complexity of Billiard Walk
   %     (Algorithm~\ref{alg:billiard}) is $O((\rho + d)k)$ 
   %     after a preprocessing step that takes $O(k^2d)$ operations, where $\rho$ is the maximum number of reflections per step.
   %  \end{lem}



   \subsubsection*{Multiphase Monte Carlo Sampling algorithm}

   \begin{figure}[!htbp]
      \includegraphics[width=1.0\columnwidth]{figures/sampling_extra_phase_croped.png}
      \caption[A Multiphase Monte Carlo Sampling algorithm]{
         An illustration of our Multiphase Monte Carlo Sampling algorithm. The method is given an integer $n$ and starts at phase $i=0$ sampling from $P_0$. In each phase it samples a maximum number of points $\lambda$. If the sum of Effective Sample Size in each phase becomes larger than $n$ before the total number of samples in $P_i$ reaches $\lambda$ then the algorithm terminates. Otherwise, we proceed to a  new phase.
    We map back to $P_0$ all the generated samples of each phase.
      }
      \label{fig:mmcs}
   \end{figure}

% MMCS RESULTS
\subsection{Results}

% MMCS DISCUSSION
\subsection{Discussion}

   Flux sampling at the community level!


% From \citet{price2004genome} :
% "Pairwise correlation coefficients can be calculated
% between all reaction fluxes based on uniform random
% sampling. Perfectly correlated reactions (R2 = 1) operate
% as functional modules within a biochemical network,
% whereas uncorrelated reactions (R2 ~0) operate independently of each other. The degree of independence
% between reactions is an important consideration when
% choosing a set of fluxes to measure that will best determine the operating state of a biochemical network"


% Write something from \citeauthor{polanyi1968life}

% \section{The `dingo` Python library}






